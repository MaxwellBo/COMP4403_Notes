\documentclass[fontsize=10pt,a4paper]{article}
\usepackage{amsmath} % Essential math and alignment (use `&` to align operators') - Google for more info
\usepackage{amssymb} % Essential symbols for sets and stuff
\usepackage{listings}

\usepackage[margin=0.3in]{geometry} % Essential document config

\usepackage[compact]{titlesec}
\titleformat*{\section}{\normalsize\bfseries\scshape}
\titleformat*{\subsection}{\small\bfseries}
\usepackage{sectsty}
\sectionfont{\fontsize{7}{9}\selectfont}
\subsectionfont{\fontsize{6}{8}\selectfont}
\subsubsectionfont{\fontsize{5}{7}\selectfont}

\newcommand{\ts}{\textsuperscript}

\usepackage{multicol} % Imports the column
\setlength{\columnseprule}{0.4pt} % Divide size

\begin{document}
\begin{multicols}{3}
    \small
    \section{Tips}

    \begin{itemize}
        \item $\epsilon$ is not a terminal symbol
    \end{itemize}

    \section{Context-free Grammars}

    Left-associative - $(1 \oplus 2) \oplus 3$

    \[E \rightarrow E \oplus T ~\vert~ T\]
    \[T \rightarrow N\]

    Right-associative - $1 \oplus (2 \oplus 3)$

    \[E \rightarrow T \oplus E ~\vert~ T\]
    \[T \rightarrow N\]

    \[E \rightarrow TE'\]
    \[E' \rightarrow \epsilon ~\vert~ \oplus TE'\]
    \[T \rightarrow N\]


    \section{Left-factoring and left-recursion removal}


    \subsection{Removing left recursion}

    \[E \rightarrow E \oplus T ~\vert~ T\]

    is transformed into

    \[E \rightarrow TE'\]
    \[E' \rightarrow \epsilon ~\vert~ \oplus TE'\]

    This transformers a left-associative grammar into a right-associative grammar

    \subsection{Recogniser Code}

    $T$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    tokens.match(Token.T);
    \end{lstlisting}

    $N$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    parseN();
    \end{lstlisting}

    $S_1 \dots S_n$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    recog(S_1); ...; recog(S_n);
    \end{lstlisting}

    $S_1 \vert S_2 \vert \dots S_n$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    if (token.isIn(First(S_1))) {
        recog(S_1);
    } ...
    } else if (tokens.isIn(First(S_n))) {
        recog(S_n);
    } else {
        errors.error("Syntax error");
    }
    \end{lstlisting}



    $[S]$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    if (token.isIn(First(S))) {
        recog(S);
    }
    \end{lstlisting}

    ${S}$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    while (token.isIn(First(S))) {
        recog(S);
    }
    \end{lstlisting}

    $(S)$
    \begin{lstlisting}[language=Java, basicstyle=\tiny]
    recog(S);
    \end{lstlisting}



    \section{First, Follow, and LL(1)}


    \subsection{Calculating First sets}

    \begin{itemize}
        \item If production of form $N \rightarrow \epsilon$, add $\epsilon$ to first set for $N$ to indicate nullability
        \item If production of form \\$N \rightarrow S_1 S_2 \ldots S_n$, then if \\$\forall i \in 1..n, \forall j \in 1..i-1 \cdot S_j$ is nullable, we add current first set for $S_i$ to first set for $N$
        \item If every construct $S_1, \ldots, S_n$ is nullable, add $\epsilon$ to first set for $N$
    \end{itemize}

    Perform for all productions, repeating the process until no sets are modified

    \section{Bottom up parsing}

    \subsection{LR(x) parsing automaton}

    Don't forget to first add production: $S' \rightarrow E$.

    \subsection{LR(x) parsing action conflicts}

    There is no such thing as a \textit{shift/shift} conflict


    \subsection{LR(1) parsing algorithm}

    Put $\$0$ on the \textit{Parsing stack}, and the input string, followed by $\$$, in the \textit{Input} queue

    \begin{enumerate}
        \item Choose transition action based on look-ahead. If it is
        \begin{enumerate}
            \item \textit{shift}, dequeue start symbol of \textit{Input} queue, and put dequeued symbol on the \textit{Parsing stack}
            \item \textit{reduce}, pop start symbol of the \textbf{RHS} of the reduction, and all stack elements above the start symbol, off the stack. Transition to state indicated by number currently on top of stack. Put reduced symbol on the stack. \textit{If LR(1), choose production s.t. $queue_0 \in T$, where $T$ is look-ahead set}. Follow transition path of current state, based on the reduced symbol.
            \item \textit{accept}, do nothing
        \end{enumerate} 
        \item Put number indicating current state on the stack

    Repeat numbered process

    \end{enumerate}



    \subsection{Subsection Header}
    \subsubsection{Subsubsection Header}

\end{multicols}

\end{document}

